---
description:
globs:
alwaysApply: true
---

# Use a Modular File Structure:

Use the /app directory for routing (App Router) with Next.js on latest version or version provided.
Keep business logic separate from UI components.
Organize your project with clear directories: /components, /hooks, /services, /lib, /styles, /interfaces.

# App Router Best Practices:

Use file-based routing for cleaner code organization.
Utilize Next.js server components for improved performance where possible.
Keep client components focused on state management and UI interactions.

# Data Access Layer (DAL) and Services:

Avoid mixing data fetching logic directly in components.
Always create a directory for services.

# Directory Structure for DAL:

Use a consistent folder structure for data access and actions within each page module, for example:

- src/
  - service/
    - /data-access # Data Access Layer (DAL)
    - /actions # Server actions 

# Component Placement Guidelines

## 1. Page-Level Components

- **Always check** When creating a new project structure or folder, component, always follow the following Example for new service, page, hook, component, context:
    ```
    src/
â”œâ”€â”€ ğŸ“ components/                   # React Components
â”‚   â”œâ”€â”€ ğŸ“ Buttons/                  # Reusable Buttons
â”‚   â”‚   â”œâ”€â”€ NameOfTheButton/
â”‚   â”œâ”€â”€ ğŸ“ NameOfTheComponent/      # Component
â”œâ”€â”€ ğŸ“ config/                      # Environment Configs
â”‚   â””â”€â”€ environment.tsx
â”œâ”€â”€ ğŸ“ context/                     # React Context
â”‚   â”œâ”€â”€ ğŸ“ NameOfTheContext/
â”œâ”€â”€ ğŸ“ errors/                      # Error 
â”‚   â””â”€â”€ errorHandler.ts
â”œâ”€â”€ ğŸ“ hooks/                       # Custom Hooks 
â”‚   â”œâ”€â”€ useCan.ts
â”œâ”€â”€ ğŸ“ pages/                       # Pages (Next.js Pages Router)
â”‚   â”œâ”€â”€ _app.tsx
â”‚   â”œâ”€â”€ _document.tsx
â”‚   â”œâ”€â”€ index.tsx
â”œâ”€â”€ ğŸ“ services/                    # API Services
â”‚   â”œâ”€â”€ ğŸ“ interfaces/
â”‚   â”œâ”€â”€ api.ts
â”‚   â”œâ”€â”€ exampleService.ts
â”œâ”€â”€ ğŸ“ styles/                      # Estilos globais
â”‚   â”œâ”€â”€ ğŸ“ components/              # Reusable components styles
â”‚   â”œâ”€â”€ ğŸ“ pages/                   # Style for the page on /pages
â”‚   â”œâ”€â”€ ğŸ“ themes/
â”‚   â”œâ”€â”€ global.ts
â”‚   â””â”€â”€ styled.d.ts
â”œâ”€â”€ ğŸ“ types/                       # Type Definitions TypeScripts
â”œâ”€â”€ ğŸ“ utils/                       # Utils        
    ```
  - What to do:
    If the component is only used within this specific page or route (e.g., only in `/src/page`), place it inside the `/src/components` folder.

## 2. Global or Shared Components

- If the component will be reused in multiple pages or modules, place it in the global `/src/components` directory.
  - Only add components to `/src/components` when you're sure they will be reused broadly.
  - If in doubt, always ask first before placing it globally.

## 3. Server vs. Client Component

- Default to Server Components (no `"use client"` directive) whenever possible.
  - Use Client Components (`"use client"`) **only when strictly necessary** (state, effects, event handlers, etc.).
  - If you're not sure, start as a Server Component and refactor to Client only if required.

## 4. Other Best Practices

- Prefer colocating components near where they're used (feature or route-level scope) unless you have a clear case for global reuse.
- Keep component directories organized and use descriptive names.
- Review import paths after moving or adding components to avoid breaking references.
- **Always** name the folder as `_components` (with a leading underscore) to distinguish it from pages/routes.

# Reusable and Isolated Components:

Keep components small and focused on a single responsibility.
Use props effectively and avoid excessive prop drilling by leveraging context or hooks where needed.
- **Always**  If the component being created is reusable and a folder for it already exists within /components, insert it into that folder. For example, for a Button Component, if the /Button folder already exists, then insert it inside /components/Button. Otherwise, create a folder with a name that matches the purpose of the reusable component inside /components/[ComponentName].

# Separation of Concerns:

Avoid placing API calls or business logic inside components.
Use hooks for state management and side effects (e.g., useSWR, React Query, custom hooks).

# UI and State Separation:

Keep UI components presentational (no logic other than rendering).
Use containers for data management and complex state logic.
Code Quality

# UI and Styling

Component Libraries

- Use styled-components for consistent, accessible component design and style.
- Only if provided use Tailwind or Chakra UI.
- Apply composition patterns to create modular, reusable components.

# TypeScript First:

Use TypeScript to ensure type safety across the application.
Define strict types for props, state, and API responses.

# Clean Code Principles:

Follow SOLID principles where applicable.
Use meaningful variable names and avoid magic numbers.
Prefer functional components and hooks over class components.

# Avoid Anti-Patterns:

No large, monolithic components.
Avoid inline styles in favor of TailwindCSS or modular CSS.
Performance Optimization

# Code Splitting and Lazy Loading:

Use dynamic imports for large components to improve load times.
Optimize for faster Time to Interactive (TTI).

# Server Components

- Default to Server Components
- Use URL query parameters for data fetching and server state management
- Use 'use client' directive only when necessary:
- Event listeners
- Browser APIs
- State management
- Client-side-only libraries

# Specific Naming Patterns

- Prefix event handlers with 'handle': handleClick, handleSubmit
- Prefix boolean variables with verbs: isLoading, hasError, canSubmit
- Prefix custom hooks with 'use': useAuth, useForm
- Use complete words over abbreviations except for:
- err (error)
- req (request)
- res (response)
- props (properties)
- ref (reference)

# Testing Strategy:

Use Jest and React Testing Library for unit and integration tests.
Aim for high test coverage on critical components and services.

# Documentation:

Use JSDoc or TypeScript comments to describe component props and functions.
Keep README files updated for each module or library used.
Security and Best Practices

# Environment Variables:

Use .env files for secrets and configuration.
Never expose sensitive keys in the frontend.

# Input Validation and Sanitization:

Use Zod for schema validation to prevent bad data.
Sanitize all inputs to prevent XSS and SQL injection.

# Authentication and Authorization:

Use AuthJS 5 for manage autentication.
Implement CSRF protection and secure cookies.
Deployment and Scalability

# Optimized Build Process:

Use the latest Next.js features for optimized builds.
Leverage Vercel or a VPS with good caching strategies.

# Logging and Error Handling:

Use tools like Sentry for error tracking and performance monitoring.
Implement graceful error handling with fallback components.

# Scaling Strategies:

Plan for horizontal scaling with serverless or containerized deployments.
Optimize database queries with Prisma or Drizzle for efficient data access.
Continuous Improvement

# Code Reviews and PR Guidelines:

Set clear code review guidelines to catch issues early.
Use pull request templates to ensure consistency.

# Performance Audits:

Regularly run Lighthouse and Web Vitals checks.
Use performance monitoring tools to track improvements.

# Stay Up-to-Date:

Keep dependencies updated and stay aware of breaking changes in major libraries like Next.js, React, and Prisma. If a specific version is provided for a library, always use the given version to ensure compatibility and avoid unexpected behavior.
